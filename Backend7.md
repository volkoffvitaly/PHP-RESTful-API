# Практика №7

## Темы

1. Изучение PHP.
2. REST API. 
3. Изучение асинхронных запросов. 

## Задачи

1. Изучить спецификаию API.
2. Изучить основы PHP. 
3. Изучить асинхронные запросы. *__По желанию__*
4. Разработать сайт, реализующий API, описанный в спецификации. 

### Спецификация API
#### Пользователи:
##### Get
* **/users/\{id\}**  
Возвращает информацию о конкретном пользователе  
Доступно только для всех пользователей  
**Ответ:** Сущность пользователя (без пароля, без ДР, отображает имя статуса, а не номер, город)
Админ видит ещё и ДР, роль
* **/users**  
Возвращает список пользователей в системе  
Доступно для всех пользователей  
**Ответ:** список пользователей (без паролей, без ДР, отображает имя статуса, а не номер, город)
Админ видит ещё и др., роль
  
##### Post
* **/users**    
Создание пользователя.    
**Модель:**  
```
{
	Name: string  
	Surname: string  
	Username: string  
	Password: string  
	Birthday: Date?
}  
```  
**Ответ:** 200 OK  
Доступно неавторизованному пользователю, админу.  
Добавить проверку, что не существует пользователя с таким же Username.   
После создания юзера происходит логин автоматоически (если создавал не админ)
  
* **/users/\{id\}/avatar**  
Загрузка аватара для пользователя  
**Модель:** 
```
{
    File: File
}
```
Файл сохраняется на сервере, генерируется ссылка и устанавливается в качестве аватара пользователя.  
Если аватар существовал до загрузки нового аватара, то предыдущий файл удаляется.  
Доступно только для администратора или самого пользователя  
**Ответ:** Сущность пользователя (без пароля)  
* **/login**
Авторизация пользователя  
**Модель:**  
```
{
	Username: string
	Password: string
}
```
**Ответ:** Bearer token авторизации  
* **/logout**
Логаут пользователя  
Ответ: 200 OK
##### Patch
* **/users/\{id\}**  
Обновление информации о пользователе.  
**Модель:**
```
	Name: string
	Surname: string
	Username: string
	Password: string
	Birthday: Date? 
	Avatar: string - ссылка на аватарку (на сервере)
```
Если поле пустое, то сохраняется предыдущее значение  
Доступно администратору и самому пользователю для себя  
**Ответ:** Сущность пользователя (без пароля, отображает имя статуса, а не номер)  

* **/users/\{id\}/city**  
Устанавливает пользователю город  
**Модель:**
```
{
    CityID: ID
}	
```
**Ответ:** 200 OK

* **/users/\{id\}/status**  
Обновление статуса пользователя  
**Модель:**
```
{
	status: enum (Online, Offline, Do not disturb, In panic, Want to die)
}
```
Доступно администратору и самому пользователю для себя  
**Ответ:** 200 OK  
* **/users/\{id\}/role**

Установка роли пользователю  
**Модель:**  
```
{
	RoleID: ID
}
```
Доступно администратору.  
**Ответ:** 200 OK

##### Delete
* **/users/\{id\}**  
Удаление пользователя. Доступно только админу  
**Ответ:** 200 OK
#### Города:
##### Get
* **/cities/\{id\}**  
Возвращает информацию о конкретном городе  
**Ответ:** сущность города
* **/cities**
Возвращает список городов. Доступно всем пользователям  
**Ответ:** список городов
* **/cities/\{id\}/peoples**  
Возвращает список пользователей для конкретного города  
**Ответ:** Список пользователей (Нет пароля, нет ДР, отображается статус)  
##### Post  
* **/cities**  
Создание города. Доступно только  администратору  
**Модель:** 
```
{
	Name: String (Required)  
}
```
**Ответ:** 200 OK  
  
##### Patch  
* **/cities/\{id\}**  
Редактирование города. Доступно только администратору  
**Модель:** 
```
{
	Name: String (Required)  
}
```
**Ответ:** 200 OK  
##### Delete  
* **/cities/\{id\}**  
Удаление города. Доступно только админу.   
**Ответ:** 200 OK  
#### Фото:  
##### Get  
* **/photos**  
**Ответ:** список фотографий текущего пользователя  
Доступно самому пользователю  
* **/user/photos/\{userId\}**  
**Ответ:** список фотографий конкретного пользователя  
Доступно любому пользователю  
##### Post  
* **/photos**  
Загрузка фотографий  
**Модель:** 
```
{
	File: File  
}
```
Файл сохраняется на сервере, генерируется ссылка.  
Доступно только для авторизованного пользователя  
**Ответ:** Сущность фотографии (ID, Creator, Link)  
##### Delete  
* **/photos/\{id\}**  
Удаление фото. Доступно админу или самому пользователю (своё фото).   
**Ответ:** 200 OK  
#### Роль:  
##### Get  
* **/roles/\{id\}**  
Возвращает информацию о конкретной роли   
**Ответ:** сущность роли  
* **/roles**  
Возвращает список ролей  
**Ответ:** список ролей  
##### Post  
* **/roles**  
Создание роли. Доступно только админу.   
**Модель:** 
```
{
	Name: String (Required)  
}
```
**Ответ:** 200 OK  
##### Patch  
* **/roles/\{id\}**  
Редактирование роли. Доступно только админу.   
Доступно редактирование только кастомных ролей (т.е. системные сущности недоступны для редактирования)  
**Модель:** 
```
{
	Name: String (Required)  
}
```

**Системные роли:**
* admin  
* moderator  
* user  

**Ответ:** 200 OK  
##### Delete  
* **/roles/\{id\}**  
Удаление роли. Доступно только админу.   
Доступно удаление только кастомных ролей (т.е. системные сущности недоступны для удаления)  
**Ответ:** 200 OK  
  
#### Пост:  
##### Get  
* **/users/\{userId\}/posts**  
Получение списка постов по автору  
**Ответ:** список постов  
* **/posts**  
		Получение списка постов   
		**Ответ:** список постов  
* **/posts/\{postId\}**  
		Получение конкретного поста   
		**Ответ:** сущность поста  
##### Post   
* **/posts**  
Создание поста  
**Модель:** 
```
{
	UserId: ID  
	Text:String (Required) 
}
```
**Ответ:** 200 OK  
##### Patch  
* **/posts/\{id\}**  
Редактирование поста. Доступно автору, админу или модератору  
**Модель:** 
```
{
	Text:String (Required)  
}
```
**Ответ:** 200 OK  
##### Delete  
* **/posts/\{id\}**  
Удаление поста. Доступно автору, админу или модератору  
**Ответ:** 200 OK  
  
#### Сообщение:   
##### Get 
* **/messages/\{messageId\}**  
		Получение конкретного сообщения. Доступно отправившему пользователю, пользователю, которому предназначалось сообщение.  
		**Ответ:** сущность сообщения  
* **/users/\{userId\}/messages/?offset=\{offset=0\}&limit=\{limit=5\}**  
Получение списка сообщений пользователя.  
**Параметры:**  

```userId```: ID пользователя  
```offset```: Сколько сообщений пропустить  
```limit```: Количество сообщений на странице (если 0 - отдавать максимум сообщений. Максимум = 100)  

**Ответ:** список сообщений  
* **/messages**  
Получение списка сообщений, отправленных тебе или тобой  
**Ответ:** список сообщений  
##### Post:  
* **/users/\{userId\}/messages/**  
Отправка сообщения пользователю  
Параметры:  
	userId - ID пользователя  
**Модель:** 
```
{
    message: string
}
```  
**Ответ:** ID сообщения  
##### Delete:  
* **/messages/\{messageId\}**  
Удаление отправленного сообщения  
Доступно для отправителя, получателя и администратора  
**Ответ:** 200 ОК  

## Результат
Ваша задача заключается в разработке сайта (backend), удовлетворяющего спецификации и диаграме классов: 

![Domain Model](Images/class.png)  

Для реализации сервера используйте PHP. 
```
    Ранее в задачу входила доработка frontend, в частности была необходима доработка кода с целью добавления запросов fetch.
```

## Материалы
### ASP.NET Core
Хотя в рамках данной лабораторной работы мы будем работать с языком PHP, важно понимать, что реализовать backend с использованием REST API можно и используя ASP.NET Core.
Самый простой способ этого добиться - использовать контроллер следующего вида: 
```csharp
    [Produces("application/json")] // Говорит о том, что результатом будет JSON
    [Route("api/test")] //позволяет переопределить роутинг    
    public class TestController : Controller
    {
        [HttpGet]
        public JsonResult Get() //В данном случае мы можем не писать Index, благодаря роутингу выше всё равно откроется этот метод. 
        {
            var test = new Example(20, "John");
            return Json(test); //Конвертация объектов модели в JSON
        }
        [HttpGet("info")] //Если вам нужно несколько методов GET в рамках одного контроллера, передайте параметр - имя действия
        public JsonResult AnotherGet()
        {
            return Json("This is info");
        }
    }
```

Если перейти по адресу ```/api/test```, то получим:
```json
{"age":20,"name":"John"}
```

Если перейти по адресу ```/api/test/info```, то получим: 

```json
"This is info"
```
Тем самым, меняя метод, по которому доступно действие (action) мы можем реализовать полноценный REST: [Все аттрибуты HTTP[verb] и их использование](https://docs.microsoft.com/ru-ru/aspnet/core/mvc/controllers/routing?view=aspnetcore-2.1#attribute-routing-with-httpverb-attributes). 
### Асинхронные запросы
```
Deprecated - ранее было необходимо использовать данную технологию, чтобы отправлять запросы с клиента на сервер, используя JS. 
Можете изучить для общего развития. 
```
В данном руководстве будет рассмотрен только один метод - fetch. Однако в списке статей представлены и альтернативные методы, которые можно использовать. 

Fetch API предоставляет интерфейс JavaScript для доступа и обработки частей протокола HTTP, таких как запросы и ответы. Оно также предоставляет глобальный метод fetch(), который даёт лёгкий, логический способ для извлечения ресурсов асинхронно по сети.

Fetch обеспечивает обобщенное определение объектов Request и Response (и других вещей, связанных с сетевыми запросами).
Метод fetch() принимает один обязательный аргумет —  путь к данным, которые вы хотите получить. Он возвращает promise, который разрешается в Response независимо от того, был ли запрос удачным. Вы можете также передать во втором аргументе необязательный объект с указанием опций.

Как только Response выполнится успешно, становятся доступными несколько методов для определения тела контента и, как его содержимое должно быть обработано.

Вы можете создавать запрос и ответ непосредственно, используя конструкторы Request() и Response(), но маловероятно, что в этом есть необходимость. Напротив, более вероятно, что они будут созданы как результат работы другого API. 
#### Пример GET-запроса
Простейщий GET запрос с помощью функции fetch() будет иметь следующий вид:
```js
 fetch('https://api.github.com/users/fabpot')
    .then(response => response.json()) // преобразуем ответ в json
    .then(data => {
        console.log(data) // выводим в консоль результат выполнения response.json()
    })
.catch(error => console.error(error))
```


#### Промисы
В данном примере используются так называемые промисы (Promise) - это специальные объекты, которые содержит своё состояние. Вначале pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

На promise можно навешивать коллбэки двух типов:
* onFulfilled – срабатывают, когда promise в состоянии «выполнен успешно».
* onRejected – срабатывают, когда promise в состоянии «выполнен с ошибкой».

Способ использования, в общих чертах, такой:

1. Код, которому надо сделать что-то асинхронно, создаёт объект promise и возвращает его.
2. Внешний код, получив promise, навешивает на него обработчики.
3. По завершении процесса асинхронный код переводит promise в состояние fulfilled (с результатом) или rejected (с ошибкой). При этом автоматически вызываются соответствующие обработчики во внешнем коде.

Возвращаясь к примеру, можно пояснить, что, по-сути, происходит следующее: 
1. Мы пытаемся обратиться к внешнему ресурсу (гитхаб). 
2. Полученный ответ мы конвертируем в формаит JSON и передаём дальше по цепочке промисов. 
3. Полученные данные (уже в формате JSON) выводятся в консоль. 
4. Если что-то пошло не так, то ошибка выводится в консоль. 

.catch является одним из способов установить обработчик onRejected, который так же можно добавить как второй параметр then. 
Поставив .catch в конец цепочки мы, тем самым, применили её ко всем .then. 

Обработчик .catch(onRejected) получает ошибку и должен обработать её.

Есть два варианта развития событий:

1. Если ошибка не критичная, то onRejected возвращает значение через return, и управление переходит в ближайший .then(onFulfilled).
2. Если продолжить выполнение с такой ошибкой нельзя, то он делает throw, и тогда ошибка переходит в следующий ближайший .catch(onRejected).

Это также похоже на обычный try..catch – в блоке catch ошибка либо обрабатывается, и тогда выполнение кода продолжается как обычно, либо он делает throw. Существенное отличие – в том, что промисы асинхронные, поэтому при отсутствии внешнего .catch ошибка не «вываливается» в консоль и не «убивает» скрипт.

Ведь возможно, что новый обработчик .catch будет добавлен в цепочку позже.

#### Заголовки запроса
```js
 fetch('https://api.github.com/users/fabpot', {
  headers: new Headers({  // устанавливаем заголовки
    'User-agent': 'Chrome/64.0 My Own Agent'
  })
})
.then(response => response.json())   // получаем ответ в виде промиса
.then(data => {
  console.log(data)                 // выводим данные в консоль
})
.catch(error => console.error(error)) // или ошибку, если что-то пошло не так
```
#### POST/PUT-запросы
```js
 post('https://appdividend.com/api/v1/users', {user: 'Krunal'})
  .then(data => console.log(data))      // обрабатываем результат вызова response.json()
  .catch(error => console.error(error))

function post(url, data) {
  return fetch(url, {
    credentials: 'same-origin',  // параметр определяющий передвать ли разные сессионные данные вместе с запросом
    method: 'POST',              // метод POST 
    body: JSON.stringify(data),  // типа запрашиаемого документа
    headers: new Headers({
      'Content-Type': 'application/json'
    }),
  })
  .then(response => response.json()) // возвращаем промис
}
```
Имейте в виду, что отправка таким методом отличается от обычного сабмита формы методом POST, т.к. в данном случае мы отсылаем сырой запрос в формате JSON. В таком случае, на стороне сервера мы должны корректно обработать этот запрос. 

#### Отправка файлов
```js
postFile('http://example.com/api/v1/users', 'input[type="file"].avatar') //Второй параметр здесь это селектор для инпута, из которого нужно достать картинку.
  .then(data => console.log(data))
  .catch(error => console.error(error))

function postFile(url, fileSelector) {
  const formData = new FormData()
  const fileField = document.querySelector(fileSelector)
  
  formData.append('username', 'abc123')
  formData.append('avatar', fileField.files[0])

  return fetch(url, {
    method: 'POST', // 'GET', 'PUT', 'DELETE', etc.
    body: formData  // Coordinate the body type with 'Content-Type'
  })
  .then(response => response.json())
}
```

Здесь же используется механизм отправки формы, а не JSON, т.к. отправляем файл. Для того, чтобы отправлять данные как будто мы сабмитим форму, используется FormData. В этом случае на стороне сервера происходит то же, что и при обычном сабмите формы. 
### REST API
REST API подразумевает под собой простые правила:
* Каждый URL является ресурсом
* При обращении к ресурсу методом GET возвращается описание этого ресурса
* Метод POST добавляет новый ресурс
* Метод PUT изменяет ресурс
* Метод DELETE удаляет ресурс

Эти правила предоставляют простой CRUD интерфейс для других приложений, взаимодействие с которым происходит через протокол HTTP.

REST API интерфейс очень удобен для межпрограммного взаимодействия, например мобильное приложение может выступать в роли клиента, который манипулирует данными посредством REST.

### PHP
#### Основы
Синтаксис языка схож с JS, представлен в [PHP](https://www.php.net/manual/ru/getting-started.php) и оставляется на самостоятельное изучение. 

Если при разработке на PHP не использовать фреймворков, то применяются следующие правила: 
* При обращении по адресу ```/folder/subfolder``` будет произведён поиск файла ```/folder/subfolder/index.php```
* PHP является исполняемым языком, то есть он не компилируется, а исполняется на лету. 
* Допустим как функциональный, так и ООП-стиль. 

#### Глобальные переменные
В таких переменных как $_GET и $_POST находится информация о данных, переданных с помощью GET и POST запросов соответственно. 

В переменной $_REQUEST собрана информация, содержащая данные $_GET и $_POST.

$_SERVER это массив, содержащий информацию, такую как заголовки, пути и местоположения скриптов. Именно используя данную переменную можно получить метод, по которому пользователь обратился к ресурсу. 

$_SESSION - ассоциативный массив, содержащий переменные сессии, которые доступны для текущего скрипта 

$_FILES - Ассоциативный массив элементов, загруженных в текущий скрипт через метод HTTP POST (обратите внимание, если вы отправил иформу с данными, включающими в себя файлы, то всё, кроме файлов будет в $_POST, в то время, как файлы будут представлены в этой переменной).

#### Routing
Роутинг — это маршрутизация: входящий URL разбирается специальным образом и по его результату выполняется определенный код, всё это мы уже использовали в ASP.NET Core, только там это было уже автоматизированно, т.к. использовался фреймворк. 

Любой входящий URL на сервере разбирается по единому стандарту: в адресе передается параметр path (путь на сервере), которого на сервере реально может не быть. Например в адресе http://сайт/admin каталога admin реально может не существовать.

То есть сервер, получив такой адрес, попытается найти каталог admin, но не найдя его, выдаст 404-страницу (not found).

Чтобы исключить такой вариант, серверу указывается, что для всех несуществующих каталогов и файлов, подключать php-файл (обычно index.php).

Делается это в файле .htaccess с помощью Apache-модуля mod_rewrite. Далее представлен довольно типовой вариант:
```
<IfModule mod_rewrite.c>
RewriteEngine on
RewriteBase /
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule ^(.+)$ index.php?q=$1 [L,QSA]
AddDefaultCharset UTF-8
# Display errors or not
php_flag display_errors on 

</IfModule>
```

Тут главная строчка с RewriteRule — именно она определяет шаблон входящего адреса (в примере это регулярное выражение) и что с ним делать. В данном примере будет подключен index.php с параметрами после слэша.
При этом, путь начинается от корня вашего сайта, то есть, если вы хотите поместить обработку в отдельную папку API, то строчка будет выглядеть так: 
```
RewriteRule ^(.+)$ API/index.php?q=$1 [L,QSA]
```
Лично я так и рекоменбдую делать. В таком случае файл .htaccess помещается в ту же папку API, чтобы не перенаправлять пути, которые не имеют отношения к API. 

Строчка ```RewriteCond %{REQUEST_FILENAME} !-f / -d``` указывает исключить из обработки реально существующие на сервере файлы и каталоги.



Итого, входящий адрес преобразуется в набор query-параметров. Например адрес http://сайт/admin превратится в http://сайт/index.php?q=admin, хотя в браузере путь не изменится, то есть не произойдёт редирект пользователя. С использованием такого подхода можно реализовать так называемые ЧПУ - человеко читаемые урлы. 

Чтобы проверить, как это работает, разместите в index.php следующее: 
```php
<?php
print_r($_GET);
```
То мы можем увидеть query-параметры. В PHP за это отвечается суперглобальная переменная $_GET. Например для http://сайт/admin это будет q=admin, для http://сайт/admin/new-page — q=admin/new-page.

Таким образом, с помощью .htaccess происходит первая часть роутинга, где мы получаем готовый $_GET

Второй этап роутинга выполняется полностью на PHP. Получив $_GET нужно решить что с ним делать. Например если адрес admin, подключить файл admin.php.

Итак, давайте напишем обработку в файле index.php: 

```php
// Определяем метод запроса
$method = $_SERVER['REQUEST_METHOD'];

// Получаем данные из тела запроса
$formData = getFormData($method);

```
getFormData просто удобная обёртка, которая позволит упростить получение доступа к данным запроса:
```php

function getFormData($method) {
 
    // GET или POST: данные возвращаем как есть
    if ($method === 'GET') return $_GET;
    if ($method === 'POST') return $_POST;
 
    // PUT, PATCH или DELETE
$data = array(); //создание нового массива
    $exploded = explode('&', file_get_contents('php://input')); 
    //Здесь мы разбили массив, полученный из потока ввода php://input по разделителю &, тем самым получив список ключ = значение
 
    foreach($exploded as $pair) {
        $item = explode('=', $pair);
        if (count($item) == 2) {
            $data[urldecode($item[0])] = urldecode($item[1]);
        }
    return $data;
 
}
```
Однако здесь есть нюанс. Обработка POST здесь ориентирована на то, что вы отправили данные как FormData, если вы вы шлёте JSON, то строчку с обработкой POST можно убрать вообще (если вы НЕ планируте отсылать данные кк FormData), либо модифицировать так: 
```php
if ($method === 'POST' && !empty($_POST)) return $_POST;
```
То же применимо и к обработке остальных типов запросов. Если вы планируете общаться через JSON, то достаточно заменить всё, после обработки POST на: 
```php
return json_decode(file_get_contents('php://input'));
```
Функция json_decode конвертирует JSON в объекты PHP.

Пример: 
```js
post('http://yoursite_url', {user: 'Krunal'})
  .then(data => console.log(data))    
```

```php
$ans = getFormData("POST");
echo json_encode(array(
        'method' => 'POST',
        'data' => $ans->user //получаем значение конкретного поля нашего объекта, полученного из JSON
    )); 
```

Если попытаться написать универсальную функцию, то выглядть она будет как-то так: 
```php
function getFormData($method) {    
    if ($method === 'GET') return $_GET;
    if ($method === 'POST' && !empty($_POST)) return $_POST;

    $incomingData = file_get_contents('php://input');
    $decodedJSON = json_decode($incomingData); //пытаемся преобразовать то, что нам пришло из JSON в объект PHP
    if ($decodedJSON) 
    {
        $data = $decodedJSON;
    } 
        else 
    {
    $data = array();
        $exploded = explode('&', file_get_contents('php://input'));     
        foreach($exploded as $pair) 
        {
            $item = explode('=', $pair);
            if (count($item) == 2) 
            {
                $data[urldecode($item[0])] = urldecode($item[1]);
            }
        } 
    }
    return $data;
}
```

Важное пояснение: когда вы отправляете GET-запрос, то все данные у вас хранятся в ПАРАМЕТРАХ запроса, а не в его теле, т.к. в GET тело не используется. 
Поэтому еесли вы хотите отправить GET-запрос и обработать его, то на стороне JS это будет выглядеть так: 
```js 
fetch('http://yoursite_url/getUser/10')
    .then(response => response.json()) 
    .then(data => {
        console.log(JSON.stringify(data))
    })
.catch(error => console.error(error))
```
На стороне PHP: 
```php
$ans = getFormData("GET");
echo json_encode(array(
        'method' => 'GET',
        'data' => $ans
    )); 
```
И в консоли вы получите: 
```js
{"method":"GET","data":{"q":"getUser/10"}}
```
Как видите, функция отлично работает. 

Возвращаемся к роутингу: 
```php
// Определяем метод запроса
$method = $_SERVER['REQUEST_METHOD'];

// Получаем данные из тела запроса
$formData = getFormData($method);

// Разбираем url
$url = (isset($_GET['q'])) ? $_GET['q'] : '';
$url = rtrim($url, '/'); //Удаляет "/" из конца строки
$urls = explode('/', $url);
```
Теперь, в $urls, при запросе GET /goods/page/2/limit/10/sort/price_asc мы получим массив: 
```php
array('goods', 'page', '2', 'limit', '10', 'sort', 'price_asc');
```

Всё, что нам осталось, это: 
```php
// Определяем роутер и url data
$router = $urls[0];
$urlData = array_slice($urls, 1); //удаляем роутер из запроса
 
// Подключаем файл-роутер и запускаем главную функцию
include_once 'routers/' . $router . '.php'; //include_once подключает внешний файл с кодом
route($method, $urlData, $formData);
```

То есть нам нужно завести папку routers, в которую мы положим файлы, манипулирующие одной сущностью (например товарами, или пользователями). При этом, стоит именовать файлы так, чтобы его название совпадало с первым параметром запроса. 

Всё, что осталось - реализовать функцию route в каждом файле роутинга:

```php
function route($method, $urlData, $formData) {    
    //Обрабатываем запрос.
    //...
    //... 
    // Выводим ответ клиенту
    echo json_encode(array(
        'method' => 'GET',
        'data' => $someVariableWithData,
        'anotherData' => 'SomeStringData',
    )); 
    return;    
}

```

Если же мы понимаем, что URL некорректен, то стоит выполнить следующий код: 
```php
// Возвращаем ошибку
header('HTTP/1.0 400 Bad Request');
echo json_encode(array(
    'error' => 'Bad Request'
));
```
Более детально данный метод разобран [здесь](https://webdevkin.ru/posts/backend/restful-servis-na-nativnom-php), тут можно почитать про реализацию всех методов и посмотреть примеры обработки запросов. 

#### Особенности работы с файлами
```php
<?php
$uploads_dir = '/uploads';
foreach ($_FILES["pictures"]["error"] as $key => $error) {
    if ($error == UPLOAD_ERR_OK) {
        $tmp_name = $_FILES["pictures"]["tmp_name"][$key];
        // basename() может предотвратить атаку на файловую систему;
        // может быть целесообразным дополнительно проверить имя файла
        $name = basename($_FILES["pictures"]["name"][$key]);
        move_uploaded_file($tmp_name, "$uploads_dir/$name");
    }
}
?>
```
```php 
move_uploaded_file ( string $filename , string $destination ) : bool
```

Эта функция проверяет, является ли файл filename загруженным на сервер (переданным по протоколу HTTP POST). Если файл действительно загружен на сервер, он будет перемещён в место, указанное в аргументе destination.
Если результирующий файл уже существует, он будет перезаписан.

#### Работа с БД
Для того, чтобы начать работу с БД нужно сначала к ней подключиться. Для этого выполним следующий код: 
```php
<?php
$link = mysqli_connect("127.0.0.1", "my_user", "my_password", "my_db");

if (!$link) {
    echo "Ошибка: Невозможно установить соединение с MySQL." . PHP_EOL;
    echo "Код ошибки errno: " . mysqli_connect_errno() . PHP_EOL;
    echo "Текст ошибки error: " . mysqli_connect_error() . PHP_EOL;
    exit;
}

echo "Соединение с MySQL установлено!" . PHP_EOL;
echo "Информация о сервере: " . mysqli_get_host_info($link) . PHP_EOL;
$res = $mysqli->query("SELECT id FROM test ORDER BY id ASC");
if (!$res) //SQL
{
    echo "Не удалось выполнить запрос: (" . $mysqli->errno . ") " . $mysqli->error;
}
else
{
    while ($row = $res->fetch_assoc()) 
    {
        echo " id = " . $row['id'] . "\n";
    }
}


mysqli_close($link); //закрытие соединения, выполняется, когда мы закончили работать с БД
?>
```

Более подробно можно почитать [тут](https://www.php.net/manual/ru/mysqli.quickstart.statements.php).

#### Аутентификация 
Аутентификация Bearer токеном это аутентификация, при которой используется токен, дающий понять, что за пользователь сейчас взаимодействует с сайтом. При этом пара логин-пароль передаётся только при получении токена, а значит лишний раз не передаётся по сети. 

Алгоритм: 
1. Пользователь посылает логин и пароль на сервер (POST). 
2. Сервер получает эти данные и првоеряет их на корректность. 
3. Если пользователь найден, сервер генерирует токен, который где-то хранится (например в БД). Обычно у него есть срок годности. 
4. Токен передаётся пользователю в ответ на его запрос и сохраняется в памяти клиента (например в Local storage JS)
5. При выполнении каждого запроса, требующего подтверждение пользователя посылается специальный хэдер: ```Authorization: Bearer <token>```, где <токен> - значение токена. 

#### Работа с LocalStorage в JS: 
```js
localStorage.setItem('token', token);
let token = localStorage.getItem('token');
localStorage.removeItem('token'); //Удаление ключа в случае выхода из учётной записи. 
localStorage.clear(); //Или полная очистка 
```
#### Работа со стороны PHP
дял того, чтобы получить все хэдеры, можно воспользоватсья функцией: 
```php
getallheaders(); 
```

#### Классы в PHP
##### StdClass
По факту, StdClass является пустым динамичным классом, который по поведению поход на JS. 
Для того, чтобы корректно сформировать ответ в формате JSON как раз можно использовать именно его. 
```php
<?php
$std = new stdClass();
$std->first = 1;
$std->second->third = 3;
print_R($std);
?>
```

При выполнении выведет: 

```
stdClass Object
(
    [first] => 1
    [second] => stdClass Object
        (
            [third] => 3
        )

)
```
Для того, чтобы получить JSON достаточно передать объект в ```json_encode($var)```.

##### OOP
```php
class ClassName
{
  // (определение класса)
  public $propertyName;
  private $propertyName;
  protected $propertyName;
}
```
Правило хорошего тона: каждый класс помещайте в отдельный файл с названием, совпадающим с именем класса. Например, поместите класс Member в файл Member.php и храните его в папке, допустим, classes.

Объекты же порождаются следующим образом:
```php
$member = new Member();
```
Работа с объектами: 
```php
<?php
 
class Member
{
  public $username = "";
  public function methodName() {
    // (код)
  }

  private function methodName() {
    // (код)
  }

  protected function methodName() {
    // (код)
  }
}
 
$member = new Member();
$member->username = "Fred";
echo $member->username;  // Выведет "Fred"
 
?>
```



### Статьи
* [Бесплатный сервер](https://beget.com/p54518/free-hosting)
* [Web API ASP.NET Core](https://docs.microsoft.com/ru-ru/aspnet/core/web-api/index?view=aspnetcore-2.2)
* [Простой способ реализовать REST API на ASP.NET Core](https://docs.microsoft.com/ru-ru/aspnet/core/web-api/advanced/formatting?view=aspnetcore-2.0)
* [Все аттрибуты HTTP[verb] и их использование](https://docs.microsoft.com/ru-ru/aspnet/core/mvc/controllers/routing?view=aspnetcore-2.1#attribute-routing-with-httpverb-attributes)
* [PHP](https://www.php.net/manual/ru/getting-started.php)
* [REST API PHP](https://webdevkin.ru/posts/backend/restful-servis-na-nativnom-php)
* [Routing PHP](http://www.itlessons.info/php/routing-library/)
* [Ещё Routing PHP](http://maxsite.org/page/routing/)
* [jQuery.ajax()](http://api.jquery.com/jquery.ajax/)
* [XMLHttpRequest](https://learn.javascript.ru/ajax-xmlhttprequest)
* [Fetch API](https://myrusakov.ru/javascript-fetch-api-part-1.html)
* [Промисы JS](https://learn.javascript.ru/promise)
* [Работа с БД](https://www.php.net/manual/ru/mysqli.quickstart.statements.php)
* [Bearer Authentication](https://swagger.io/docs/specification/authentication/bearer-authentication/)
* [PHP ООП](https://ruseller.com/lessons.php?id=1145)